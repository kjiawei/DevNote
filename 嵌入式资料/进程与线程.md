3.多线程/进程&并发
C++ socket库  https://blog.csdn.net/fengbingchun/article/details/46349379
3.1 每个线程都有一个栈,保存自己的局部变量,多线程上锁保护全局变量和静态变量(存在.bss段)
3.2 CPU:运算核心（Core）和控制核心（ControlUnit）  寄存器在其中,操作数据比内存快(速度:寄

存器>cache>RAM>ROM)
http://www.cnblogs.com/Mushrooms/p/5151593.html
同步异步 信号量与互斥锁

不断捕捉信号：while(-1 != pause());
###进程：一个正在内存中运行的有生老病死的程序（动态）
为什么需要进程：多任务【协同父进程处理多任务】，例：1秒刷一张图片
ps-进程状态[ps -ef查看系统当前正在运行进程信息]
###1.创建
①pid_t fork(void);创建子进程的时候会复制它老爸所有的资源；返回0：子进程，大于0 父进程， 小于0 失败；一次调用，两次返回；
②vfork共享父（代码段 数据段）资源，无法用sleep干预，照样是子进程先执行；
执行注意：
先分出父进程（未参与创建子进程代码）代码和子进程（创建及后续）代码；先运行父进程代码再运行子进程代码；子不能复制父亲代码和父亲独有代码；
tips:创建子进程过程中使用sleep函数可让父进程挂起，使子进程有足够时间去执行
###2.获取进程ID
当前getpid();父getppid();//输出时需要转换为int型
###3.退出
①exit();//退出刷新IO缓存区  exit(0)是正常退出其他都不是
②_exit();//退出不刷新IO缓存区
③return 0;//回到调用函数
exit(0);//退出进程,用处：出错直接退出程序
###4.回收
如果父进程没有主动回收子进程，会变成孤儿进程，最终会被1号进程init【祖进程】回收
①wait();//阻塞父进程直到子进程退出然后回收子进程,成功返回子进程id，失败-1；参数stat_loc是指宏函数去获取的进程信息；
②waitpid();//返回值和参数补充
![微信截图_20170405143125.png](http://upload-images.jianshu.io/upload_images/2636843-4e5f491272b5f326.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
###5.进程间通信方式：
1.有、无名管道
①有：int mkfifo(const char *pathname, mode_t mode);动生成一个管道文件用于进程间的通信，纯粹linux环境，无血缘要求，创建前判断有无，【前面没删点后面不能操作】；只写模式下只有内容被取后才能取消阻塞（读写权限的话对方无法获取内容）；
system干掉卡住的进程，access()判断文件是否存在；
②无：int pipe(int fildes[2]);临时存放数据，读端和写端是固定的，具有血缘关系（父子和兄弟之间）的进程通信，没有名字（看不到）；  
2.共享内存，消息队列，信号量
①共享(申请，映射，删除)效率最高：key值手写或ftok生成，size为1024整数倍；
查看：ipcs -m
3.信号
4.unix域套接字（网络编程）
5.套接字（网络编程）

###线程：
取消
优先级
属性
线程间同步互斥：互斥锁  条件变量  信号量

互斥锁：上锁了会怎样：一般会把访问共享内存这段代码放在上锁程序之后。
互斥锁特点小结（锁不使用属性）：
1.谁上谁解；
2.先上不阻塞，后上都阻塞；
第3个特点：加个延时控制
4.不能重复执行（上了要解，不解就上的话就阻塞）

条件变量：配合互斥锁使用，不可单独
1.pthread_cond_init   destroy
2.唤醒pthread_cond_broadcast(所有阻塞在这个线程上的)signal（某个） 阻塞pthread_cond_wait

线程池
4.13总结：1.对没用过的东西，理解功能后尝试验证/实践,反复这个过程

pthread_cond_wait();//阻塞的，解开互斥锁并让当前线程阻塞在条件变量上
//阻塞并解锁
pthread_cond_signal();//唤醒阻塞在cond条件变量上的某个线程，解除对线程的阻塞，然后马上上锁
//唤醒（解除阻塞）并上锁   基于cond条件变量

使用注意事项：
1.干单一事情，不要指派复杂任务；
2.一发一收（线程）
3.线程目的：帮助实现小任务

使用线程与进程都有哪些坑

###exec函数族与system
一旦执行了exec函数代码，后面的就不执行

###进程的状态
就绪：还没有获取到CPU的使用权；
CPU通过调度算法，将使用权给了进程，那么进程就自动进入到了执行态；

5.进程与线程区别
对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。

线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。

线程（默认情况不可分离）退出自己回收(分离属性)，不需要主线程（主线程的话需要调用pthread_join去回收线程）
太抽象：

   线程是轻量级的进程
   线程是系统调度的最小单位
线程：线程是把系统分配给进程的资源拿了一部分用于支持自己的运行
   线程是在进程中创建的---》创建线程的那个进程称作主线程
                           被创建的线程称作子线程

1.定义
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.
线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.
2.关系
一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.
相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。
